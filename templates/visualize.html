{% extends "base.html" %}

{% block content %}
<div class="flex flex-col items-center justify-center text-center">
    <h1 class="text-4xl font-bold text-gray-900 mb-6">Interactive Graph Visualization</h1>
    <p class="text-lg text-gray-600 max-w-2xl mb-8">
        Explore the relationships between datasets and their properties in a dynamic force-directed graph.
    </p>
    <div class="bg-white rounded-lg shadow-lg p-4 w-full h-[800px] flex items-center justify-center relative">
        <p id="loading-graph" class="text-gray-500 text-center">Loading graph data...</p>
        <svg id="graph-container" class="w-full h-full"></svg>
    </div>
</div>

<!-- D3.js library -->
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        const loadingMessage = document.getElementById('loading-graph');
        const svg = d3.select("#graph-container");
        const container = svg.node().parentNode;
        let width = container.clientWidth;
        let height = container.clientHeight;

        // Function to render the graph
        async function renderGraph() {
            width = container.clientWidth;
            height = container.clientHeight;

            svg.html(''); // Clear previous graph
            svg.attr("width", width)
               .attr("height", height)
               .attr("viewBox", `0 0 ${width} ${height}`)
               .attr("preserveAspectRatio", "xMidYMid meet");
            
            try {
                // Fixed the fetch URL to use an absolute path
                const response = await fetch(`${window.location.origin}/api/visualize`);
                if (!response.ok) {
                    throw new Error('Failed to fetch graph data');
                }
                const graphData = await response.json();
                
                loadingMessage.classList.add('hidden');

                const simulation = d3.forceSimulation(graphData.nodes)
                    .force("link", d3.forceLink(graphData.links).id(d => d.id).distance(150))
                    .force("charge", d3.forceManyBody().strength(-800)) // Increased repulsion force significantly
                    // Removed .force("center", d3.forceCenter(width / 2, height / 2)) to allow nodes to spread out
                    ;

                const link = svg.append("g")
                    .attr("stroke", "#999")
                    .attr("stroke-opacity", 0.6)
                    .selectAll("line")
                    .data(graphData.links)
                    .join("line");

                const node = svg.append("g")
                    .attr("stroke", "#fff")
                    .attr("stroke-width", 1.5)
                    .selectAll("circle")
                    .data(graphData.nodes)
                    .join("circle")
                    .attr("r", 10)
                    .attr("fill", d => d.group === 1 ? "#6b46c1" : "#d53f8c")
                    .call(d3.drag()
                        .on("start", dragstarted)
                        .on("drag", dragged)
                        .on("end", dragended));

                const labels = svg.append("g")
                    .attr("class", "labels")
                    .selectAll("text")
                    .data(graphData.nodes)
                    .enter().append("text")
                    .text(d => d.id)
                    .attr("font-size", "12px")
                    .attr("pointer-events", "none")
                    .attr("text-anchor", "middle");

                simulation.on("tick", () => {
                    link
                        .attr("x1", d => d.source.x)
                        .attr("y1", d => d.source.y)
                        .attr("x2", d => d.target.x)
                        .attr("y2", d => d.target.y);

                    node
                        .attr("cx", d => d.x)
                        .attr("cy", d => d.y);
                    
                    labels
                        .attr("x", d => d.x)
                        .attr("y", d => d.y - 15);
                });

                function dragstarted(event, d) {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                }

                function dragged(event, d) {
                    d.fx = event.x;
                    d.fy = event.y;
                }

                function dragended(event, d) {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                }

            } catch (error) {
                console.error('Error fetching graph data:', error);
                loadingMessage.textContent = 'Failed to load graph data. Please check the API.';
                loadingMessage.classList.remove('hidden');
            }
        }
        
        // Initial render
        renderGraph();

        // Handle window resizing
        window.addEventListener('resize', () => {
            renderGraph();
        });
    });
</script>
{% endblock %}
